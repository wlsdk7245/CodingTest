## # 완주하지 못한 선수
**\[문제 설명\]**

수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.

마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.

**\[제한사항\]**

-   마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.
-   completion의 길이는 participant의 길이보다 1 작습니다.
-   참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.
-   참가자 중에는 동명이인이 있을 수 있습니다.

**\[입출력 예\]**

<table style="border-collapse: collapse; width: 100%; height: 58px;" border="1" data-ke-style="style1"><tbody><tr><td style="width: 33.2558%;">participant</td><td style="width: 33.3721%;">completion</td><td style="width: 33.3721%;">return</td></tr><tr style="height: 19px;"><td style="height: 19px; width: 33.2558%;">[leo,<span>&nbsp;</span>kiki,<span>&nbsp;</span>eden]</td><td style="height: 19px; width: 33.3721%;">[eden,<span>&nbsp;</span>kiki]</td><td style="height: 19px; width: 33.3721%;">leo</td></tr><tr style="height: 10px;"><td style="height: 10px; width: 33.2558%;">[marina,<span>&nbsp;</span>josipa,<span>&nbsp;</span>nikola,<span>&nbsp;</span>vinko,<span>&nbsp;</span>filipa]</td><td style="height: 10px; width: 33.3721%;">[josipa,<span>&nbsp;</span>filipa,<span>&nbsp;</span>marina,<span>&nbsp;</span>nikola]</td><td style="height: 10px; width: 33.3721%;">vinko</td></tr><tr style="height: 19px;"><td style="height: 19px; width: 33.2558%;">[mislav,<span>&nbsp;</span>stanko,<span>&nbsp;</span>mislav,<span>&nbsp;</span>ana]</td><td style="height: 19px; width: 33.3721%;">[stanko,<span>&nbsp;</span>ana,<span>&nbsp;</span>mislav]</td><td style="height: 19px; width: 33.3721%;">mislav</td></tr></tbody></table>

**\[입출력 예 설명\]**

예제 #1  
leo는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.

예제 #2  
vinko는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.

예제 #3  
mislav는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.

**\[첫 번째 제출\]**

```
#include <string>
#include <vector>
using namespace std;

string solution(vector<string> participant, vector<string> completion) {
    string answer = "";
    
    for(int i=0; i<completion.size(); i++){
        for(int j=0; j<participant.size(); j++){
            if(participant[j]==completion[i]){
                participant.erase(participant.begin()+j);
                break;
            }
        }
    }
    
    answer=participant[0];
    return answer;
}
```

위 코드는 정확도는 100%이지만 효율성이 0%로 시간 초과로 실패했다. 아마 for문을 두 번 돌리는 과정에서 배열의 크기가 커졌을 때 효율성이 떨어지는 것으로 보인다.

**\[두 번째 제출\]**

```
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

string solution(vector<string> participant, vector<string> completion) {
    string answer = "";
    sort(participant.begin(), participant.end());
    sort(completion.begin(), completion.end());
    
    for(int i=0; i<participant.size(); i++){
        if(participant[i]!=completion[i]){
            answer=participant[i];
            break;
        }
    }
    return answer;
}
```

두 번째 방법으로, 두 벡터를 먼저 정렬하고 첫 원소부터 비교를 시작하면, 같지 않은 원소가 나올 때, participant에 있지만 completion에는 없는 원소가 존재한다는 의미이기 때문에 answer에 participant\[i\]를 넣어주었다. 또 그럴 경우 더 이상 비교를 하지 않아도 되기 때문에 break를 통해 반복문을 종료해준다. 이렇게 했더니 정확성과 효율성 테스트에서 모두 통과할 수 있었다.

검색을 해본 결과, map등의 방법을 통해 해결하는 사람들이 있는데, map에 관련된 개념은 아직 부족하기 때문에 이 부분은 보충해서 공부해야 할 것 같다. 또 애초에 이 문제의 분류가 해시이기 때문에, 해시 개념도 SW Expert Academy 사이트에서 공부를 해야한다.